# 老码识途

<https://zhuanlan.zhihu.com/p/458672910>

## 第1章 欲向码途问大道，锵锵bit是吾刀

* 资料下载：<https://cbjj.phei.com.cn/module/zygl/manager/uploadfiles/17382.rar>

### 1.1 全局变量引发的故事

#### 1.1.1 剖析赋值语句的机器码

实验视频：
<https://www.bilibili.com/video/BV1fP4y1j7uG?spm_id_from=333.999.0.0>

* 掌握VS2008中的调试操作
* 提出问题：
  * Q1:gi的地址在内存的哪？
  * Q2:mov指令放在内存的哪？
* Q1:
  * 探索全局变量gi在内存中的保存形式
    * 猜测：
      * 从内存中的机器码猜测
        * 指令包含
          * mov指令
          * 要赋值的内存地址
          * 要赋的值
    * 如何放在内存中？ 小端机
  * 给gi赋值的改变，内存中的四个字节也跟着改变
* Q1解决

#### 1.1.2 修改赋值语句的机器码

* Q2:
  * mov指令如果存在内存中，且可以修改内存中的值，那我们就可以通过修改内存里的值来修改指令
  * 以小端机顺序将想要gi修改的值直接写入内存中
* Q2解决

#### 1.1.3 直接构建新的赋值语句

实验视频：<https://www.bilibili.com/video/BV1Rr4y1v7Qk?spm_id_from=333.999.0.0>

* 以上几步可以概括为：猜测->实证，接着我们要尝试->构建
* IP寄存器(EIP寄存器)的值与指令地址相同
* 用jmp指令以机器码的形式在正常的C代码中嵌入汇编
  * 思路：![](https://raw.githubusercontent.com/youhuangla/images/main/20220116213515.png)
  * jmp和mov的机器码
  * 调试的安全性问题
    * VS2008:
        > 配置->配置属性->链接器->高级->数据执行保护(DEP)=否，避免堆栈段不可执行。
  * 执行后gi的值改变

#### 1.1.4 小结

> 通过本节，我们了解了调试环境的反汇编、监视窗口、内存窗口、单步、断点、mov指令、全局变量赋值的反汇编、大端机/小端机，对指令建立了形象的认知，并直接构建了指令。
全局变量赋值引发的学习过程就是我们探索式学习很好的缩影，分为由浅及深的三阶段：深入剖析一部分修改—全新构建。我们要善于将自己的探索过程分解为递进的阶段，而这些阶段又由诸多设问和实证组成、推进。通过这样的锻炼，我们能渐渐磨炼出自己的学习和探索能力。记住，设问和实证为心灵的自由插上了一对翱翔的翅膀。

### 1.2 理解指针和指针强制转换

#### 1.2.1 指针和它丢失的类型信息

##### 指针变量存储的信息

> 指针存储了内存的地址，同时指针是有类型的，如int＊、float＊，那么，一个自然的猜想就是指针变量应该存储这两方面的信息：

1. 地址
2. 指针类型

`sizeof(int *)`与`sizeof(float *)`都是4，指针变量（地址）的大小似乎都是4字节，与1.1节全局变量的地址大小相同。

> 既然4字节是存储内存地址用的，反过来就说明指针并没有存储类型信息的地方。那么，为什么指针要有类型？为什么还要有指针类型强制转换？而且不转换，不同类型的指针无法赋值（如int *不能直接赋值给float*,会产生编译错误）。

p11

> 读／写多少字节的信息不是存放在指针变量中，而是放到了与该地址相关的赋值指令中，mov 指令中的dword指明了这个信息。
