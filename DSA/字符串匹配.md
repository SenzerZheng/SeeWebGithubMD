# 字符串匹配

上

## 朴素匹配算法 Brute-Force

单模匹配

模式串

逐个比较，在母串中找到模式串

```cpp
/*************************************************************************
	> File Name: 1.string_match.c
	> Author: 
	> Mail: 
	> Created Time: Sun Oct  2 21:22:26 2022
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_N 10000
#define DEFAULT_LEN 40
char s[MAX_N + 5], t[MAX_N + 5];

#define TEST(func) { \
	char temp_s[MAX_N + 5]; \
	sprintf(temp_s, "%s(\"%s\", \"%s\") = %3d\n", #func, s, t, func(s, t)); \
	int n = DEFAULT_LEN - strlen(temp_s); \
	while (n--) printf(" "); \
	printf("%s", temp_s); \
}

int brute_force(const char *s, const char *t) {
	// return the first time find string, s is mother string, t is son
	for (int i = 0; s[i] != 0; i++) {
		bool flag = true;
		for (int j = 0; t[j] != 0; j++) {
			if (s[i + j] == t[j]) {
				continue;
			}
			flag = false;
			break;
		}
		if (flag) return i;
	}
	return -1;
}

int test_func(const char *s, const char *t) {
	return -1;
}

int main() {
	while (~scanf("%s%s", s, t)) {
		TEST(brute_force);
		TEST(test_func);
	}
	return 0;
}

```



```shell
youhuangla@Ubuntu string_match % gcc 1.string_match.c                                                                               [0]
youhuangla@Ubuntu string_match % ./a.out                                                                                            [0]
hello ello
     brute_force("hello", "ello") =   1
       test_func("hello", "ello") =  -1
helloworld low
 brute_force("helloworld", "low") =   3
   test_func("helloworld", "low") =  -1
```

## hash匹配法 Rabin-Karp

演示的是大概的算法，原算法自己扩展

滑动窗口
$$
Hash_A = a \times base ^ 3 + e \times base ^ 2 + c \times base ^ 1 + a \times base ^ 0 \\
Hash_B = e \times base ^ 3 + c \times base ^ 2 + a \times base ^ 1 + e \times base ^ 0 \\
\text {2式 = 1式乘base，再加一个减一个}=> Hash_B = Hash_A \times base + e \times base ^ 0 - a \times base ^ 4
$$
最后一个 4 是模式串的长度。

哈希值相等则进行比较；不等则肯定不匹配，不比较。

朴素（暴力）：$O(n \times m)$

哈希：$O(n \times m \div p) \approx O(n)$，p是用于取余的值，哈希冲突的概率是$\frac {1} {p}$。若 $p \approx m$，复杂度约为 $O(n)$。如果想看具体怎么算，找本数据结构书。

p 选个大质数，为什么要设置成质数，大概会出现 p - 1 种余数，涉及数论。base 选奇数？小的质数？ 59:26

### 快速幂算法

如何快速计算 $a ^ {10}$？

10的二进制：1 0 1 0

位权：8 4 2 1

$a^8$  $a^4$ $a^2$  $a^1$

依次遍历二进制中的每一位，如果当前二进制位是1，那么我们就当前位置对应的次方累乘进结果

$a^ {10} = a ^ 8 \times a ^ 2$

```cpp
44:		if (b & 1) { //b&1判断当前二进制(b)末尾是不是1，如果是1则累乘入ans中
```

```cpp
47:			b >>= 1;//b / 2 去掉b二进制表示的最后一位
```

```cpp
/*************************************************************************
	> File Name: 1.string_match.c
	> Author: 
	> Mail: 
	> Created Time: Sun Oct  2 21:22:26 2022
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_N 10000
#define DEFAULT_LEN 40
char s[MAX_N + 5], t[MAX_N + 5];

#define TEST(func) { \
	char temp_s[MAX_N + 5]; \
	sprintf(temp_s, "%s(\"%s\", \"%s\") = %3d\n", #func, s, t, func(s, t)); \
	int n = DEFAULT_LEN - strlen(temp_s); \
	while (n--) printf(" "); \
	printf("%s", temp_s); \
}

int brute_force(const char *s, const char *t) {
	// return the first time find string, s is mother string, t is son
	for (int i = 0; s[i] != 0; i++) {
		bool flag = true;
		for (int j = 0; t[j] != 0; j++) {
			if (s[i + j] == t[j]) {
				continue;
			}
			flag = false;
			break;
		}
		if (flag) return i;
	}
	return -1;
}

int quick_mod(int a, int b, int c) { // 快速幂算法
	int ans = 1, temp = a;
	while (b) {
		if (b & 1) { //b&1判断当前二进制(b)末尾是不是1，如果是1则累乘入ans中
			ans = ans * temp % c;
			temp = temp * temp % c;
			b >>= 1;//b / 2 去掉b二进制表示的最后一位
		}
	}
	return ans;
}

int hash_match(const char *s, const char *t) {
	int len = strlen(t), base = 31, P = 9973, nbase = quick_mod(base, len, P);
	int h = 0;
	for (int i = 0; s[i]; i++) {
		s[i];//1:08:53
	}
}

int test_func(const char *s, const char *t) {
	return -1;
}

int main() {
	while (~scanf("%s%s", s, t)) {
		TEST(brute_force);
		TEST(test_func);
	}
	return 0;
}

```



