# 6.循环

## for语句

> ### 语法
>
> 属性说明符序列(C23 起)(可选) `for` `(` *初始化子句* `;` *条件表达式* `;` *迭代表达式* `)` 循环语句
>
> ### 解释
>
> 表现如下：
>
> - *初始化子句* 可以为表达式或声明 (C99 起)
>
> | 作为声明的 *初始化子句* 在整个循环体内都处于作用域内，包括 *初始化子句* 的剩余部分、整个*条件表达式*、整个 *迭代表达式* 及整个*循环语句*。声明于此声明的变量只允许有 `auto` 和 `register` [存储类说明符](https://zh.cppreference.com/w/c/language/storage_duration)。 | (C99 起) |
> | ------------------------------------------------------------ | -------- |
>
> - *条件表达式* 在循环体前求值。若表达式的结果是零，则循环立即退出。
> - *迭代表达式* 在循环体后求值，并舍弃其结果。求值 *迭代表达式* 后，将控制转移到 *条件表达式*。
>
> [for 循环 \- cppreference\.com](https://zh.cppreference.com/w/c/language/for)

### 逗号运算符(comma)

逗号表达式的格式如下所示：
[逗号表达式] 　　表达式1, 表达式2
这里的表达式1 和表达式2 是两个任意的表达式。逗号表达式的计算要通过两步来实现：第一步，计算表达式1 并且扔掉计算出的值。第二步，计算表达式2 ，把这个值作为整个表达式的值。对表达式1 的计算应该始终会有副作用；如果没有，那么表达式1 就没有了存在的意义。

提供逗号运算符是为了在C语言要求只能有一个表达式的情况下可以使用两个或多个表达式。换句话说，逗号运算符允许将两个表达式“粘贴”在一起构成一个表达式。（注意与复合语句的相似之处，后者允许我们把一组语句当作一条语句来使用。）

需要把多个表达式粘在一起的情况不是很多。正如后面的某一章将介绍的那样，某些宏定义（➤14.3节）可以从逗号运算符中受益。除此之外，for 语句是唯一可以发现逗号运算符的地方。

注意：像声明中的逗号运算符，不可视作两个表达式的粘贴，而是多个变量具有相同类型时的合并：

```c
int i, int j;   
/*
❌
error: expected identifier or ‘(’ before ‘int’
 int a, int b;
        ^~~
*/
int i, j;//right
```

> #### 内建的逗号运算符
>
> 逗号运算符表达式的形式为
>
> *表达式1* `,` *表达式2*  
>
> 在逗号表达式 E1, E2 中，对 `E1` 求值并[舍弃](https://zh.cppreference.com/w/cpp/language/expressions#.E5.BC.83.E5.80.BC.E8.A1.A8.E8.BE.BE.E5.BC.8F)它的结果（尽管当它具有类类型时，直到[包含它的全表达式的结尾](https://zh.cppreference.com/w/cpp/language/lifetime#.E4.B8.B4.E6.97.B6.E5.AF.B9.E8.B1.A1.E7.9A.84.E7.94.9F.E5.AD.98.E6.9C.9F)之前都不会销毁它），它的副作用在表达式 `E2` 的求值开始前完成（注意，用户定义的 `operator,` 不能保证定序） (C++17 前)。
>
> 逗号表达式结果的类型、值和值类别和它的第二操作数 `E2` 的类型、值和值类别完全相同。如果 `E2` 是临时量表达式 (C++17 起)，那么表达式的结果是该临时量表达式 (C++17 起)。如果 `E2` 是位域，那么结果是位域。
>
> [C++ 运算符优先级 - cppreference.com](https://zh.cppreference.com/w/cpp/language/operator_precedence)->[其他运算符 - cppreference.com](https://zh.cppreference.com/w/cpp/language/operator_other#.E5.86.85.E5.BB.BA.E7.9A.84.E9.80.97.E5.8F.B7.E8.BF.90.E7.AE.97.E7.AC.A6)

> 请考虑表达式 `e1, e2`。 表达式的类型和值是 *e2*的类型和值;计算 *e1* 的结果被丢弃。 如果右操作数是左值，则结果为左值。
>
> [逗号运算符：, | Microsoft Docs](https://docs.microsoft.com/zh-cn/cpp/cpp/comma-operator?view=msvc-170)

> 逗号运算符“,”也是C 语言优先级最低的运算符，在for 语句中经常会用到它。被逗号分隔的一对表达式将按照从左到右的顺序进行求值，表达式右边的操作数的类型和值即为其结果的类型和值。
> 
> 《K&R C》中文译本p70

#### 练习

```c
a = 5, a++, a * 3;//expression = 18, a = 6
t = 1, t + 5, t++;//ex = 1, t = 2
x = (a = 3 * 5, a * 4);//ex = 60, x = 60, a = 15
```

Q：表达式`x=a=3,6*a`是（)表达式，表达式的结果是（),执行后x的值是（)。

A：由于逗号运算符的优先级最低，故先计算`x = a = 3`表达式，由于赋值运算符的结合性是从右到左，故`x = (a = 3)`，a先被赋值为3。整个逗号表达式舍弃了左边的值，表达式右边的操作数的类型和值即为其结果的类型和值(K&R)，故表达式值为18。

> 逗号
> 18
> 3

##### for循环打印乘法表

```c
#include <stdio.h>
int main() {
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= i; j++) {
            //j == 1 || printf("\t");//用短路等价于if语句
            if (j != 1) {
                printf("\t");
            }
            printf("%d * %d = %d", j, i, i * j);
        }
        printf("\n");
    }
    return 0;
}
```

```c
1 * 1 = 1
1 * 2 = 2       2 * 2 = 4
1 * 3 = 3       2 * 3 = 6       3 * 3 = 9
1 * 4 = 4       2 * 4 = 8       3 * 4 = 12      4 * 4 = 16
1 * 5 = 5       2 * 5 = 10      3 * 5 = 15      4 * 5 = 20      5 * 5 = 25
1 * 6 = 6       2 * 6 = 12      3 * 6 = 18      4 * 6 = 24      5 * 6 = 30      6 * 6 = 36
1 * 7 = 7       2 * 7 = 14      3 * 7 = 21      4 * 7 = 28      5 * 7 = 35      6 * 7 = 42      7 * 7 = 49
1 * 8 = 8       2 * 8 = 16      3 * 8 = 24      4 * 8 = 32      5 * 8 = 40      6 * 8 = 48      7 * 8 = 56      8 * 8 = 64
1 * 9 = 9       2 * 9 = 18      3 * 9 = 27      4 * 9 = 36      5 * 9 = 45      6 * 9 = 54      7 * 9 = 63      8 * 9 = 72      9 * 9 = 81
```

## while语句

### 练习

#### 改写辗转求余算法

```c
#include <stdio.h>

int main() {
    int m, n, r;
    scanf("%d,%d", &m, &n);
    #if 0
    if (m < n) {
        r = m;
        m = n;
        n = r;
    }
    /*
    if可以去掉。
    原来是比较m和n的值，并将m替换为较大值，n替换为较小值。
    那么我们可以去掉if后，输入一个m,n，使得m > n，若运算仍等价即可证明if可以去掉。
    */
    #endif
    //若输入数字m > n，例如为9,6时。m == 9, n == 6
    r = m;
    m = n;
    n = r;
    //r == 9, m == 6, n == 9
    do {
        r = m % n;//第一遍r == 6;
        m = n; //第一遍m == 9;
        n = r;//第一遍n == 6;
        //第一遍到此，又转换为m = max(6, 9), n == min(6, 9)
        //故即使去掉了if语句后，输入数字经过了多一次的循环，仍然将m替换为两者中的较大值，n替换为较小值，两者等价
    } while (r != 0);
    printf("%d\n", m);
    return 0;
}
```

Q1: if能否去掉？

Q2: 将do...while循环改为while循环

```c
#include <stdio.h>

int main() {
    int m, n, r;
    scanf("%d,%d", &m, &n);
    while (r != 0) {
        r = m % n;
        m = n;
        n = r;
    }
    printf("%d\n", m);
    return 0;
}
```

Q3: 求最小公倍数

```c
#include <stdio.h>

int main() {
    int m, n, r;
    scanf("%d,%d", &m, &n);
    int origin_m = m, origin_n = n;
    while (r != 0) {
        r = m % n;
        m = n;
        n = r;
    }
    int gcd = m;
    int lcm;
    lcm = origin_n / gcd * origin_m;
    printf("%d\n", lcm);
    return 0;
}
```

